from random import randint

# СОБСТВЕННЫЙ КЛАСС ТОЧЕК НА ПОЛЕ
class Dot:
    # __init__ -конструктором класса (метод, который автоматически вызывается при создании объектов)
    # Вызов метода – это операция создания объекта;тк объект создается в момент вызова класса по имени, то в этот момент вызывается метод __init__.
    def __init__(self, x, y):  # self - только что созданный объект; x,y - присваиваемые объекту свойства
        self.x = x
        self.y = y

    # Метод eq используется для определения поведения оператора равенства (==) для объектов класса.
    # позволяет указать, как объекты класса должны сравниваться на предмет равенства.
    # для сравнения точек друг с другом метод eq ( 1-ый арг - главный объект, 2-ой арг - объект с кот сравниваем гл объект)
    def __eq__(self, other):
        return self.x == other.x and self.y == other.y # когда будет код a == b , то будет вызываться метод eq (вид: a.__eq__(b)) и сравниваться тут

    #__repr__() возвращает строку, являющуюся допустимым выражением Python, которое можно использовать для воссоздания объекта
    #это метод вывода точек в консоль (a = Dot(1,2) , b = Dot(2,3) => print ([a,b]) => в консоли будет список [Dot(1,2), Dot(2,3)]
    # нужно для проверки точки в списке (print (a in aa)) где aa = [Dot(1,2), Dot(2,3) и тд]
    def __repr__(self):
        return f"Dot({self.x}, {self.y})"



# СОБСТВЕННЫЕ КЛАССЫ ИСКЛЮЧЕНИЙ
#общий класс исключений
class BoardException(Exception)  :# общий класс исключений, кот будет содержать в себе все остальные классы исключений
    pass

#классы пользовательских исключений
class BoardOutException(BoardException):#выстрел за пределы игровой доски
    def __str__(self):
        return "Вы пытаетесь выстрелить за пределы доски"
class BoardUsedException(BoardException):#выстрел в уже использованную клетку
    def __str__(self):
        return "Вы уже стреляли в эту клетку"

#класс исключений, кот. пользователю не будем показывать (неправильное размещение кораблей)
class BoardWrongShipException(BoardException):
     pass

# КЛАСС КОРАБЛЯ НА ИГРОВОМ ПОЛЕ
#создание корабля через конструктор класса
class Ship:
    def __init__(self, bow, l, o):
        self.bow = bow #точка, где размещен нос корабля (класс точки Dot)
        self.l = l #длина корабля
        self.o = o #ориентация корабля (0 - верт, 1 - горизонтально)
        self.lives = l #количество жизней(сколько точек корабля еще не подбито)

    @property#тк вычисляет свойство
    #метод, кот возвращает список всех точек корабля; применяем к объекту класса Корабля
    def dots(self):
        ship_dots = [] #изначально пустой список точек корабля
        # проходимся циклом от 0 до "длина -1"
        for i in range(self.l):
            cur_x = self.bow.x #сначала координата x носа корабля; далее по циклу след клетка в соответствии с ориентацией
            cur_y = self.bow.y #координата y носа корабля; далее по циклу след клетка в соответствии с ориентацией
            # если ориентация горизонтальная, то движемся по оси x вбок
            if self.o == 0:
                cur_x += i
            # если ориентация вертикальная, то движемся по оси y вверх
            elif self.o == 1:
                cur_y += i
            # добавляем точку в список точек корабля
            ship_dots.append(Dot(cur_x, cur_y))
        #продолжаем цикл или конец цикла
        return ship_dots  #возвращаем список всех точек корабля
#проверка (убрать property)
# s = Ship(Dot(1,2), 4, 0)
# print(s.dots())
# вывод в терминале[Dot(1, 2), Dot(2, 2), Dot(3, 2), Dot(4, 2)]

    #метод, кот показывает попали мы в корабль или нет
    def shooten(self, shot): #self - созданный объект класса Ship, shot - выстрел - (координаты точки Dot)
        return shot in self.dots #через метод eq ; self.dots - списки точек корабля , вывод: True или False

#проверка (убрать property)
# s = Ship(Dot(1,2), 4, 0)
# # вывод в терминале[Dot(1, 2), Dot(2, 2), Dot(3, 2), Dot(4, 2)]
# print(s.shooten(Dot(1,2)))
#True (попали в точку корабля)

#КЛАСС ИГРОВОЕ ПОЛЕ
class Board:
    #задаем доску
    def __init__(self, hid = False, size = 6): #hid- нужно ли скрывать , size - размер поля
        self.size = size
        self.hid = hid

        self.count = 0 #счетчик кол-ва пораженных кораблей
        self.field = [["0"] * size for _ in range(size)] #size на size ; отображение состояния клеточек полей: 0 - в клeтку не стреляли еще, квадрат [['0', '0', '0'], ['0', '0', '0'],...]

        self.busy = [] #список занятых точек: корабли и те, куда уже стреляли
        self.ships = [] #список кораблей доски

    #вывод корабля на доску
    def __str__(self): #когда вернем , то print доску и этот метод будет вызываться
        res = "" #б записывать сюда всю доску
        res += "  | 1 | 2 | 3 | 4 | 5 | 6 |"
        #проходимся циклом по строкам доски: заодно берем индекс строки с пом энумерат ,и выводим номер строки и через | клетки строки , и далее  с новой строки
        for i, row in enumerate(self.field): #cоздает объект-генератор, который генерирует кортежи, состоящие из двух элементов – индекса элемента и самого элемента.
            res += f"\n{i+1} | " + " | ".join(row) + " |"

        if self.hid:#если истиный , то заменяем символы корабля "■" на "O"
            res = res.replace("■", "O")
        return res
    #проверка выхода за пределы доски
    def out(self, d):
        return not((0<= d.x < self.size) and (0<= d.y < self.size))
#проверка
# b = Board()
# print(b)

    #КОНТУР КОРАБЛЯ И ДОБАВЛЕНИЕ ЕГО НА ДОСКУ (продолжение #КЛАСС ИГРОВОЕ ПОЛЕ)
    def contour(self, ship, verb = False): #метод обводит корабль по контуру ( в ходе самой игры и при расстановке кораблей)
        near = [(-1, -1), (-1, 0) , (-1, 1),
                (0, -1), (0, 0) , (0 , 1), #все точки (8 штук) вокруг той, в кот мы находимся (0,0) - сама точка
                (1, -1), (1, 0) , (1, 1)]
        #для каждой точки корабля проходимся по циклу
        for d in ship.dots:
            for dx, dy in near:
                cur = Dot(d.x + dx, d.y + dy)
                if not(self.out(cur)) and cur not in self.busy: #если точка не выходит за пределы и не занята
                    if verb:#параметр нужно ли ставить точки вокруг кораболей: реальная игра или только занести в список бизи
                        self.field[cur.x][cur.y] = "." #ставим на место точки "."
                    self.busy.append(cur)#добавляем точку в список занятых

    def add_ship(self, ship):#метод добавления корабля на доску
        for d in ship.dots: #проверка каждой точки корабля
            if self.out(d) or d in self.busy: #если выходит за пределы поля или занята
                raise BoardWrongShipException()

        for d in ship.dots:
            self.field[d.x][d.y] = "■"#для каждой точки корабля проставим квадратик
            self.busy.append(d)#добавим каждую точку корабля в список занятых (корабль и соседние)


        self.ships.append(ship) #добавляем корабль в список собственных кораблей
        self.contour(ship) #обводим корабль по контуру

# b = Board()
# b.add_ship(Ship(Dot(1,2), 4, 0))
# print(b)
# print(b.busy) #точки которые окружают корабль

    #СТРЕЛЬБА ПО ДОСКЕ
    def shot(self, d): #функция выстрела (точка выстрела)
        if self.out(d): #если точка выстрела вне поля
            raise BoardOutException()

        if d in self.busy: #если точка выстрела уже в списке занятых
            raise BoardWrongShipException()

        self.busy.append(d) #добавляем точку в список занятых

        #проходимся в цикле по кораблям и проверяем принадлежит ли точка выстрела какому либо кораблю или нет
        for ship in self.ships: #self.ships - список кораблей доски
            if ship.shooten(d):
                self.lives -= 1  # количество жизней корабля уменьшаем на 1(сколько точек корабля еще не подбито)
                self.field[d.x][d.y] = "X" #self.field отображение состояния клеточек полей; помечаем подбивший выстрел 'X'

                if ship.lives == 0:  # если кол-во жизней корабля = 0
                    self.count += 1 #счетчик подбитых кораблей увеличиваем
                    self.contour(ship, verb = True) #обозначаем контур корабля
                    print(' Корабль уничтожен')
                    return False #ход дальше не нужно делать

                else: # если кол-во жизней корабля != 0
                    print(' Корабль ранен')
                    return True #игрок повторяет ход

        self.field[d.x, d.y] = "." # если корабль не был поражен то ставим .
        print('Мимо')
        return False  # заканчиваем ход

    def begin(self): #начало игры чтобы список обнулился
        self.busy = [] #точки куда игрок стрелял

    def defeat(self):#для проверки, кто выиграл
        return self.count == len(self.ships)  #выиграл, если количество подбитых кораблей == кол-ву всех кораблей на доске

    #КЛАСС ИГРОК
class Player:
    def __init__(self, board, enemy): #своя доска и доска противника
            self.board = board #своя доска
            self.enemy = enemy #доска противника

    def ask(self):#не определяем
        raise NotImplementedError()#дб у потомков этого класса

    #в бесконечном цикле пытаемся сделать выстрел
    def move(self):
        while True:
            try:
                target = self.ask() #просим пользователя или компьютер дать координаты выстрела
                repeat = self.enemy.shot(target) #делаем выстрел
                return repeat #если выстрел прошел хорошо, то возвр-ем то, нужно ли нам повторить ход
        #если выстрел прошел плохо, то выбрасываем исключение
            except BoardException as e:
                print(e)

    #КЛАССЫ "игрок-компьютер" , "игрок-пользователь"
class AI(Player):
    def ask(self):
        d = Dot(randint(0,5), randint(0,5)) #генерируем 2 точки рандомно от 0 до 5
        print(f' Ход компьютера : {d.x+1} , {d.y+1}')
        return d
class User(Player):
    def ask(self):
        while True:
            cords = input ("Ваш ход:").split()#запрос координат

            if len(cords) != 2:#проверка что введены 2 координаты
                print(" Введите 2 координаты! ")
                continue

            x , y = cords

            if not (x.isdigit()) or not (y.isdigit()):#проверка что введены 2 числа
                print(" Введите числа! ")
                continue

            x , y = int(x) , int (y)

            return Dot (x-1, y-1) #возвращаем точку (-1 тк индексация с 0)

    #КЛАСС "игра" и генерация досок (генерировать доски, заполненные кораблями)
class Game:
    #конструуктор игры
    def __init__(self, size=6):
        self.size = size #задаем размер доски
        pl = self.random_board() #генерируем доску для игрока случайно
        co = self.random_board() #генерируем доску для компьютера случайно
        co.hid = True #скрываем доску для компьютера

        self.ai = AI(co, pl) #создаем компьютер как объект класса AI, передавая доски
        self.us = User(pl, co) #создаем игрокак ак объект класса User, передавая доски

    def try_board(self): #пробуем расставить корабли на доску
        lens = [3,2,2,1,1,1,1] #список длин кораблей, кот нужно расставить
        board = Board (size = self.size)#доска, созданная по размеру
        attempts = 0 #количество попыток расставления кораблей

        # проходимся циклом по кораблям с указанными длинами [3,2,2,1,1,1,1]
        for l in lens:
            while True:#запускаем бесконечный цикл пробуя создать корабль и поставить его на доску с выбранной длиной цикла
                attempts += 1
                if attempts >= 2000:
                    return None
                ship = Ship (Dot(randint (0, self.size), randint (0, self.size)), l, randint(0,1)) #рандомно создаем корабль
                try:
                    board.add_ship(ship) #добавляем корабль на доску
                    break #прерываем бесконечный цикл если корабль добавлен
                except BoardWrongShipException:# если исключение, то продолжаем итерацию заново
                    pass

        board.begin()#очищаем доску
        return board #возвращаем нашу доску

    #метод гарантировано генерирует случ доску
    def random_board(self):
        board = None #пустая доска
        while board is None: #в бесконечном цикле пока доска пустая - создаем доску
            board = self.try_board()
        return board #как только доска не пустая возвращаем ее (здесь корабли уже расставлены по правилам)

    #ПРИВЕТСТВИЕ
    def greet(self):
        print("-------------------")
        print("  Приветсвуем вас  ")
        print("      в игре       ")
        print("    морской бой    ")
        print("-------------------")
        print(" формат ввода: x y ")
        print(" x - номер строки  ")
        print(" y - номер столбца  ")

# g = Game()
# g.size = 6   #до конструктора
# print(g.try_board())

    # ИГРОВОЙ ЦИКЛ
    def loop(self):
        num = 0 #номер хода
        while True:
            print('-'*20)
            print('Доска пользователя')
            print(self.us.board)
            print('-' * 20)
            print('Доска компьютера')
            print(self.ai.board)
            print('-' * 20)
            # далее действуем в зависимости от номера хода
            if num % 2 == 0:#если ход четный - ходит пользователь
                print('Ходит пользователь')
                repeat = self.us.move()#move()-функция выстрела; записываем результат в repeat - нужно ли повторить ход
            else:
                print('Ходит компьютер')
                repeat = self.ai.move()  # move()-функция выстрела; записываем результат в repeat - нужно ли повторить ход

            if repeat:#если выстрел прошел хорошо, то возвр-ем то, что нужно повторить ход
                num -= 1 #уменьшаем на 1, чтобы этот же игрок повторил свой ход (чтобы num осталась такой же)(внизу увеличение)

            if self.ai.board.defeat():#если количество пораженных кораблей = кол-ву кораблей на доске (или можно просто 7)
                print('-' * 20)
                print('Пользователь выиграл')
                break #условие вызода из бесконечного цикла

            if self.us.board.defeat():#если количество пораженных кораблей = кол-ву кораблей на доске (или можно просто 7)
                print('-' * 20)
                print('Компьютер выиграл')
                break #условие вызода из бесконечного цикла

            num += 1

        # МЕТОД СТАРТ, КОТОРЫЙ ВСЕ ЭТО ВМЕСТЕ СОВМЕЩАЕТ
    def start(self):
        self.greet()
        self.loop()

g = Game()
g.start()

